/**
 * Core Philosophy: This ruleset enforces a strict, administrator-only security model.
 * All data access and modification are restricted to authenticated users who are explicitly
 * designated as administrators in the `/roles_admin` collection. There is no concept of
 * member self-service or public write access; all operations are mediated by a trusted admin user.
 *
 * Data Structure: The data is organized into top-level collections for major entities like
 * `members`, `membership_plans`, `trainers`, and `attendance`. This flat structure is intentional
 * to support simple queries that do not require manual index creation. Member-specific data that is
 * not queried across all members (e.g., `memberships`, `invoices`) is nested in subcollections.
 *
 * Key Security Decisions:
 * - Admin-Only System: Access to the entire database is granted only to users whose UID exists as
 *   a document ID in the `/roles_admin` collection.
 * - Server-Mediated Public Actions: Features like public member check-in are explicitly designed
 *   to be handled by a secure Cloud Function. The rules do not grant public write access to any
 *   collection.
 * - Default Deny Posture: Any path not explicitly matched is denied by default.
 *
 * Denormalization for Authorization:
 * - Admin roles are managed via "existence over content" in `/roles_admin/{adminId}`. A `get()`
 *   is used in the `isAdmin()` function to verify this.
 *
 * Structural Segregation:
 * - The database uses clear structural separation. All collections have a homogenous security
 *   posture (admin-only). There are no collections that mix public and private data, which
 *   dramatically simplifies rule logic.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user has administrative privileges by verifying
     * their UID exists as a document in the `/roles_admin` collection.
     * This is the primary authorization check for the entire database.
     * Using get() instead of exists() is crucial to break the circular dependency
     * where checking for admin status required admin status.
     */
    function isAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/roles_admin/$(request.auth.uid)) != null;
    }

    /**
     * Ensures the incoming 'memberId' field matches the parent document's ID in the path.
     * This enforces relational integrity when creating a new document in a subcollection.
     */
    function hasCorrectMemberIdOnCreate(memberId) {
      return request.resource.data.memberId == memberId;
    }

    /**
     * Ensures the 'memberId' field is immutable on updates. This prevents an existing
     * subcollection document from being reassigned to a different member.
     */
    function isMemberIdImmutable() {
      return request.resource.data.memberId == resource.data.memberId;
    }

    // ------------------------------------------------------------------------
    // Rule Definitions
    // ------------------------------------------------------------------------

    /**
     * @description Protects the admin roles collection. A user can create their own
     *              admin role document. Any signed-in user can read an admin profile (for gymName context),
     *              but only existing admins can list all other admins. Client-side updates and
     *              deletes are forbidden to prevent privilege escalation.
     * @path        /roles_admin/{adminId}
     * @allow       (get) Any signed-in user reading an admin document to retrieve context (e.g., gymName).
     * @allow       (create) An authenticated user creating their own admin role document during signup.
     * @principle   Allows the isAdmin() function to work by letting any signed-in user `get` a role document.
     */
    match /roles_admin/{adminId} {
      allow get: if isSignedIn();
      allow list: if isAdmin();
      allow create: if request.auth.uid == adminId;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secures the main collection of gym member profiles. Only authenticated
     *              administrators are allowed to read or write member data.
     * @path        /members/{memberId}
     * @allow       (create) An authenticated admin creating a new member profile.
     * @deny        (get) A non-admin user trying to read a member profile.
     * @principle   Enforces role-based access control (RBAC) where all data is private to admins.
     */
    match /members/{memberId} {
      allow get, list, create, update, delete: if isAdmin();
    }

    /**
     * @description Secures the membership subscriptions for a specific member.
     *              Only admins can manage a member's subscriptions.
     * @path        /members/{memberId}/memberships/{membershipId}
     * @principle   Ensures data integrity by validating that subcollection data correctly references its parent.
     */
    match /members/{memberId}/memberships/{membershipId} {
      allow get, list, delete: if isAdmin();
      allow create: if isAdmin() && hasCorrectMemberIdOnCreate(memberId);
      allow update: if isAdmin() && isMemberIdImmutable();
    }

    /**
     * @description Secures the financial invoices for a specific member.
     *              Only admins can manage a member's invoices.
     * @path        /members/{memberId}/invoices/{invoiceId}
     * @principle   Ensures data integrity by validating that subcollection data correctly references its parent.
     */
    match /members/{memberId}/invoices/{invoiceId} {
      allow get, list, delete: if isAdmin();
      allow create: if isAdmin() && hasCorrectMemberIdOnCreate(memberId);
      allow update: if isAdmin() && isMemberIdImmutable();
    }

    /**
     * @description Secures the payment records for a specific member.
     *              Only admins can manage a member's payments.
     * @path        /members/{memberId}/payments/{paymentId}
     * @principle   Ensures data integrity by validating that subcollection data correctly references its parent.
     */
    match /members/{memberId}/payments/{paymentId} {
      allow get, list, delete: if isAdmin();
      allow create: if isAdmin() && hasCorrectMemberIdOnCreate(memberId);
      allow update: if isAdmin() && isMemberIdImmutable();
    }
    
    /**
     * @description Secures the top-level attendance collection. Only admins can read/write.
     *              Client-side queries must filter by gymName.
     * @path        /attendance/{attendanceId}
     * @principle   Uses a flat data structure to avoid collection group queries and manual indexes.
     */
    match /attendance/{attendanceId} {
        allow read, write: if isAdmin();
    }

    /**
     * @description Secures the collection of available membership plans.
     *              Only admins are allowed to define and manage these plans.
     * @path        /membership_plans/{planId}
     * @principle   Enforces role-based access control (RBAC) for global configuration data.
     */
    match /membership_plans/{planId} {
      allow read, write: if isAdmin();
    }

    /**
     * @description Secures the collection of gym trainer profiles. Only admins
     *              are allowed to manage trainer information.
     * @path        /trainers/{trainerId}
     * @principle   Enforces role-based access control (RBAC) for global staff data.
     */
    match /trainers/{trainerId} {
      allow read, write: if isAdmin();
    }

    // ------------------------------------------------------------------------
    // Collection Group Rules
    // ------------------------------------------------------------------------

    /**
     * @description Secures the 'invoices' collection group. Allows an admin
     *              to list invoices across ALL members. This is required
     *              for the invoicing page which uses a collectionGroup query.
     * @path        /{path=**}/invoices/{invoiceId}
     * @allow       (list) An admin listing all invoices.
     * @principle   Supports collection group queries for system-wide reporting.
     */
    match /{path=**}/invoices/{invoiceId} {
      allow list: if isAdmin();
    }
  }
}

    